<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Hello World</title>

</head>
  <script src="phaser.min.js"></script>
    <script src="phaser.js"></script>
     <script src="Character.js"></script>
    <script src="IceCharacter.js"></script>
    <script src="FireCharacter.js"></script>
    <script src="EarthCharacter.js"></script>
    <script src="WindCharacter.js"></script>
    <script src="CollisionDetector.js"></script>
    <script src="CollisionAction.js"></script>
    <script src="ContainCharacter.js"></script>
<body>
  <script type="text/javascript">
   
      var config = {
          // .AUTO tells phaser to default to WEBGL, else default to canvas
            type: Phaser.AUTO,
            width: 800,
            height: 600,
          // tells Phaser that our game requires the Arcade Physics system
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 300 },
                    debug: false
                }
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            }
      };
      
      var cursor;
      var projectiles;
      var platforms;
      var player;
      var cursors;
      var stars;
      var score = 0;
      var scoreText;
      var bombs;
      var gameOver = false;
      var dragging = false;
      
      var game = new Phaser.Game(config);
      
      function preload()
      {
          // the string sky is link to the loaded asset. used in code when creating
          // Game Objects
        this.load.image('sky', 'assets/sky.png')
        this.load.image('ground', 'assets/platform.png');
        this.load.image('star', 'assets/star.png');
        this.load.image('bomb', 'assets/bomb.png');
        this.load.image('projectile', 'images/whiteball.png');
        this.load.spritesheet('dude', 'assets/dude.png',
        { frameWidth: 32, frameHeight: 48 }
    );
      }
      
      function create()
      {
          this.add.image(400, 300, 'sky');
          //to reset the sky image to 0, 0 coords
         // this.add.image(0, 0, 'sky').setOrigin(0, 0);
          //order in which game objects are displayed matches order
          // of creation
          // this.add.image creates new Image Game Object and adds it to current Scenes display
          // list
         // this.add.image(400, 300, 'star');
          
          
          // creates new static physics group and assigns to platforms
          // in Arcade Physics, two types of physics bodies:
          // Dynamic: moves around via forces like velocity/acceleration/collides/bounces
          // Static: only has position and size, not touched by gravity, when collides, it doesn't move
          platforms = this.physics.add.staticGroup();
          
          // refresh body tells Phaser we changed a Static physics body
          platforms.create(400, 568, 'ground').setScale(2).refreshBody();
          
          platforms.create(600, 400, 'ground');
          platforms.create (50, 250, 'ground');
          platforms.create(750, 220, 'ground');
          
          // creates sprite positioned at 100, 450
          // created by Physics Game Object Factor (this.physics.add) which means it has 
          // a Dynamic Physics body by default
          player = this.physics.add.sprite(100, 450, 'dude');

            // when sprite lands after jumping it will bounce slightly
            player.setBounce(0.2);
          // set to collide with world bounds (which is outside of game dimensions)
          // we defined as 800 x 600
            player.setCollideWorldBounds(true);
      //    player.anchor.x = 0.5;
        //  player.anchor.y = 0.5;

          // define animation called left using frames 0, 1, 2, 3 from spritesheet we loaded in
          // runs at 10 frames
          // -1 value tells animation to loop
          // Animation Manager is a global system, defining an animation allows us
          // to apply it to as many Game Objects as we want
            this.anims.create({
                key: 'left',
                frames: this.anims.generateFrameNumbers('dude', { start: 0, end: 3 }),
                frameRate: 10,
                repeat: -1
            });

            this.anims.create({
                key: 'turn',
                frames: [ { key: 'dude', frame: 4 } ],
                frameRate: 20
            });

          
            this.anims.create({
                key: 'right',
                frames: this.anims.generateFrameNumbers('dude', { start: 5, end: 8 }),
                frameRate: 10,
                repeat: -1
            });
          
        // Phaser's built-in Keyboard manager
        // populates cursors object with up, down left, right properties
        // the four directions are instances of Key objects
       // cursors = this.input.keyboard.createCursorKeys();
        cursors = this.input.keyboard.addKeys({'up': Phaser.Input.Keyboard.KeyCodes.W, 
                                     'down': Phaser.Input.Keyboard.KeyCodes.S,                     'left': Phaser.Input.Keyboard.KeyCodes.A,     
                                    'right': Phaser.Input.Keyboard.KeyCodes.D,
                                                          
                                    
                                    });
        
        // creating dynamic physics group instead of static to make it bounce
        stars = this.physics.add.group({
            // any children created will be fiven the star texture by default
            key: 'star',
            // create 1 child then repeat 11 times = 12 stars total
            repeat: 11,
            // set the stars starting at 12, 0
            // first one at 12, 0  - second one 12+70, 0 => 82, 0
            // third at 152, 0 etc.
            setXY: { x: 12, y: 0, stepX: 70 }
        });

        // iterates through all the stars in the star Group and gives them random Y bounce value between 0.4 and 0.8 (the range is 0 to 1)
        stars.children.iterate(function (child) {

            child.setBounceY(Phaser.Math.FloatBetween(0.4, 0.8));

        });
          
          bombs = this.physics.add.group();
          
         // createProjectiles();
          projectiles = this.physics.add.group();
          
          
          cursor = this.physics.add.image(0,0,'cursor').setVisible(false);
          
          this.input.on('pointerdown', function(p)
        {
           // cursor.setPosition(p.x, p.y);
            var projectile = projectiles.create(player.x, player.y, 'projectile');
            projectile.setCollideWorldBounds(false);
            projectile.body.setAllowGravity(false); 
            projectile.rotation = player.rotation - (Math.PI / 2); 
          });
          
          // 16 x 16 coords
          // score: 0 is default display
          scoreText = this.add.text(16, 16, 'score: 0', { fontSize: '32px', fill: '#000' });
          
          // creates Collider object that checks collision between player and platforms Group
          this.physics.add.collider(player, platforms);
          // check collision with platforms
          this.physics.add.collider(stars, platforms);
          //check if player overlaps this a star or not
          // if overlap, then call function collectStar
          this.physics.add.overlap(player, stars, collectStar, null, this);
         // this.physics.add.collider(player, stars, collectStar, null, this);
          this.physics.add.collider(projectiles, platforms);
          
          this.physics.add.collider(bombs, platforms);
          // call hitBomb if player hits a bomb
          this.physics.add.collider(player, bombs, hitBomb, null, this);
          
           this.cameras.main.startFollow(player, true, 0.05, 0.05);
          
          
          
          
          
      }
      
      
      function update()
      {
        if (gameOver)
        {
           // gameOver = false;
            return;   
        }
          
        if (cursors.left.isDown)
        {
            player.setVelocityX(-160);

            player.anims.play('left', true);
        }
        else if (cursors.right.isDown)
        {
            player.setVelocityX(160);

            player.anims.play('right', true);
        }
        else
        {
            player.setVelocityX(0);

            player.anims.play('turn');
        }

          // if up key is pressed and player is touching floor
        if (cursors.up.isDown && player.body.touching.down)
        {
            player.setVelocityY(-330);
        }
        
          
    
        var temp = player.getWorldTransformMatrix();
          //getWorldTransformMatrix 
        var targetAngle =  Phaser.Math.Angle.Between(
          player.x, player.y,
          this.game.input.activePointer.worldX, this.game.input.activePointer.worldY);
          
        player.setRotation(targetAngle + Math.PI / 2);
    
        console.log("mousePOinter.x: " + this.game.input.mousePointer.x + "\nmousePointer.y: " + this.game.input.mousePointer.y);
          
          
        moveProjectiles();
          
        /*if (game.input.activePointer.isDown) 
        {
            fire();
        } */ 
    }  
          
      
       // physics body disabled and parent Game Object is made inactive and invisible 
        // removing it from display
        function collectStar(player, star)
        {
            
            star.disableBody(true, true);      
            
            // increment player score when he gets a star
            score += 10;
            scoreText.setText('Score: ' + score);
            
            // use Group method countActive to see how many stars are left alive
            // if player collects them all, re-enable all the stars and reset their y position
            //to 0 => make stars drop from the top of the screen again
            if (stars.countActive(true) === 0)
            {
                //  A new batch of stars to collect
                stars.children.iterate(function (child) {

                child.enableBody(true, child.x, 0, true, true);

            });

                
            /// create bombs, with x coordinate opposite side of the player to give them a chance lmao
            var x = (player.x < 400) ? Phaser.Math.Between(400, 800) : Phaser.Math.Between(0, 400);

            var bomb = bombs.create(x, 16, 'bomb');
            bomb.setBounce(1);
            bomb.setCollideWorldBounds(true);
            bomb.setVelocity(Phaser.Math.Between(-200, 200), 20);
            bomb.allowGravity = false;

    }
        }
      
      
      // stops the game and turns player Red
      function hitBomb()
      
      {
        this.physics.pause();

        player.setTint(0xff0000);

        player.anims.play('turn');

        gameOver = true;
          
          
      }
      
      
            function createProjectiles()
      {
            projectiles = this.physics.add.group();
          
          
      }
      
      function disableProjectiles()
      {
            projectiles.children.iterate(function (child) 
            {
                child.disableBody(true, true);
                                
            });    
      }
      
      function enableProjectiles()
      {
            projectiles.children.iterate(function(child) 
            {
                child.enableBody(true, player.x, player.y, true, true);
            });
      }
      
      function moveProjectiles()
      {
            projectiles.children.iterate(function(child)
            {                            
                child.x += Math.cos(child.rotation) * 10;
                child.y += Math.sin(child.rotation) * 10;
                
            });    
      }
      
      function rotateProjectile() 
      {
          projectile.rotation = player.rotation;
      }
                                         
     function fire()
        {
            var projectile = projectiles.create(player.x, player.y, 'projectile');
            projectile.setCollideWorldBounds(true);
            this.physics.moveToObject(projectile, this.game.input.activePointer, 240);
                
        }
      
  </script>
</body>
</html>